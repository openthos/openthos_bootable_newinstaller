#!/bin/busybox sh

################################################################################
# last update on 2016-9-28
# update by jianxing<wangjianxing5210@163.com> on 2016-9-8
# update by David Chan<chanuei@sina.com> on 2016-8-25
# License:GPL V2 

CMDLINE=/proc/cmdline

if [ -n "$DEBUG" -o "$BOOT_MODE" = "install" ];then
  set -x
  exec 2>>/tmp/log
fi

#echo "Init Script Enter..."

debug_shell()
{
  pushd

  if [ -e system/bin/sh ] && [ -x system/bin/sh ]; then
    echo Running MirBSD Korn Shell...
    USER="($1)" system/bin/sh -l 2>&1
  else
    echo Running busybox ash...
    sh 2>&1
  fi

  popd
}

# Begin: Early init
# ==============================================================================  
#  echo ""
#  echo "Stage early init start..."
  readonly ANDROID_DIR="/android"
  readonly LIVEMEDIA_DIR="/mnt/livemedia"
  
  PATH=/sbin:/bin:/system/bin:/system/xbin; export PATH

  if [ ! "$HAS_CTTY" = "YES" ]; then
#    echo "Early Init: Busybox installing..."
    busybox mount -t proc proc /proc
    busybox mount -t sysfs sysfs /sys
    busybox mount -t tmpfs tmpfs /android
    busybox mount -t tmpfs tmpfs /tmp
    busybox --install -s

    rm -f /sbin/mke2fs
    rm -f /sbin/mkfs*
#    echo "Early Init: Busybox installed."

    mknod /dev/tty c 5 0
    mknod /dev/tty2 c 4 2 && openvt
    mknod /dev/tty3 c 4 3 && openvt
  
    mkdir -p /dev/block
#    echo "Early Init: Devices enumerating..."
    echo /sbin/mdev > /proc/sys/kernel/hotplug
    mdev -s
    echo 3 4 1 2 > /proc/sys/kernel/printk
#    echo "Early Init: Devices enumerated."
    exec env HAS_CTTY=YES setsid cttyhack /bin/sh "$0" "$@"
  
  fi
  
#  echo "Stage early init finished."
  
# End: Early init
# ------------------------------------------------------------------------------


# Begin: Function definition
# ==============================================================================  
 
  dbg_echo()
  {
    cat $CMDLINE | grep "DEBUG" >> /dev/null

    if [ $? -ne 0 ]; then
      echo $@ >> /dev/null
    else
      echo $@
    fi
  }

  dbg_printf()
  {
    cat $CMDLINE | grep "DEBUG" >> /dev/null

    if [ $? -ne 0 ]; then
      printf $1 >> /dev/null
    else
      printf $1
    fi
  }


    #----------------------------------
    # by: David Chan (chanuei@sina.com)
    # date: 2018-05-18
    #
    # Func: wait_for_blkdev
    wait_for_blkdev()
    {
      dbg_echo -n "Waiting for Block Device ."
      local n=0
      local retBlkIdStr=""
      while [ $n -le 10 ]; do
        retBlkIdStr=`blkid`
        if [ -n "$retBlkIdStr" ]; then
          break
        fi
        dbg_echo -n .
        let ++n
        sleep 1s
      done
      dbg_echo "ready!"
    }

  #----------------------------------
  # by: David Chan (chanuei@sina.com)
  # date: 2016-08-27
  #
  # Func: dirs  
  dirs()
  {
    dbg_printf "_DIRSTACK: $PWD  "
    
    local OLDIFS="$IFS"
    IFS=":"
  
    for i in $_DIRSTACK
    do
      dbg_printf "$i  "
    done
    
    dbg_printf "\n"
    
    IFS="$OLDIFS"
  }
  
  #----------------------------------
  # by: David Chan (chanuei@sina.com)
  # date: 2016-08-27
  #
  # Func: pushd
  # Param:
  #   $1, directory to be pushed
  pushd()
  {
    local REQ="$1"
    REQ="${REQ:-.}"
    if [ ! -d $REQ ]; then
      dbg_echo "PUSHD Failed: You've tried to pushd a non-directory $REQ."
      return 1
    fi
    
    local varDIR=`pwd`
    
    if cd "$REQ"; then
      _DIRSTACK="$varDIR:$_DIRSTACK"
      dirs
      return 0
    else
      dbg_echo "PUSHD Failed: Cannot chang to directory $REQ."
      return 1
    fi
  }
  
  #----------------------------------
  # by: David Chan (chanuei@sina.com)
  # date: 2016-08-27
  #
  # Func: popd
  # Param:
  popd()
  {
    if [ -z "$_DIRSTACK" ]; then
        dbg_echo "POPD: Directory stack is empty."
        return 1
    fi
    
    if cd `echo $_DIRSTACK | cut -d: -f1`; then
      local semiPos=`expr index $_DIRSTACK ":"`
      let semiPos=$semiPos+1
      _DIRSTACK=`echo $_DIRSTACK | cut -b$semiPos-`
      dirs
      return 0
    else
      dbg_echo "POPD: change directory failed !"
      return 1
    fi
  }


  #----------------------------------
  # by: David Chan (chanuei@sina.com)
  # date: 2016-08-31
  #
  # Func: get_param_from_bootargs
  # Param:
  #   $1, nameParam of the param to be found from /proc/cmdline
  get_param_from_bootargs()
  {
    if [ "$#" -ne 1 ]; then
      dbg_echo "get_param_from_bootargs: The func should be called with 1 parameters, but $# parameters found"
      return $ERROR_PARMETER
    fi
    
    for c in `cat $CMDLINE`; do
      case $c in
      $1=*)
        local tempParam="$(echo $c | cut -d"=" -f2)"
        if [ -n "$tempParam" ]; then
          eval $1=$tempParam
          return $VALUE_FOUND
        fi
        ;;
      *)
        ;;
      esac
    done
    
    dbg_echo "get_param_from_bootargs: No value for $1 found"
    return $VALUE_MISS        
  }

  #----------------------------------
  # by: Luoyuan Xiao (xiaoluoyuan@163.com)
  # date: 2017-02-23
  #
  # Func: to_byte
  # Param:
  #   $1, size,eg:22kb,188MB
  to_byte()
  {
    local s=$1
    local size="${s%%[a-zA-Z.]*}"
    local unit="${s##*[0-9]}"

    [ "$size" = "$s" ] && {
      echo "$s"
      return
    }

    case $unit in
        PB|pb|Pb|pB|P|p)
        echo $((size << 50))
                    ;;
	TB|tb|Tb|tB|T|t)
		echo $((size << 40))
		;;
	GB|gb|Gb|gB|G|g)
		echo $((size << 30))
		;;
	MB|mb|Mb|mB|M|m)
		echo $((size << 20))
		;;
	KB|kb|Kb|kB|K|k)
		echo $((size << 10))
		;;
	B|b)
		echo $size
		;;
        esac
  }

  #----------------------------------
  # by: Luoyuan Xiao (xiaoluoyuan@163.com)
  # date: 2017-02-23
  #
  # Func: to_kb, to_mb, to_gb
  # Param:
  #   $1, size,eg:22kb,188MB
  to_kb()
  {
    local bytes
    bytes=$(to_byte "$1")
    echo $((bytes >> 10))
  }

  to_mb()
  {
    local bytes
    bytes=$(to_byte "$1")
    echo $((bytes >> 20))
  }

  to_gb()
  {
    local bytes
    bytes=$(to_byte "$1")
    echo $((bytes >> 30))
  }


  #----------------------------------
  # by: Luoyuan Xiao (xiaoluoyuan@163.com)
  # date: 2017-02-23
  #
  # Func: parted_disk_remaining_space
  # Param:
  #   $1, disk device, default currect disk. eg:/dev/sdc.
  #   $2, fs type, default "ext4". if do not formatted, set "no_fs".
  #   $3, return the remaining partition
  #   $4, return fs type

  parted_disk_remaining_space()
  {

    local cur_disk=$1
    local fs_type=$2

    if [[ $cur_disk ]];then
      if [ ${#cur_disk} -gt 8 ];then
        echo "parted_disk_remaining_space: parameter error, it should be a disk, eg:/dev/sdc"
	  return $ERROR_PARMETER
      fi
    else
      cur_disk=`cat /proc/mounts | awk '/\/mnt\/livemedia/ {print $1}' | cut -c -8 `
    fi

    [[ $fs_type ]] || fs_type="ext4"

    eval `/bin/parted $cur_disk print free | awk '/Free Space/ {printf("start=%s;end=%s;size=%s;",$1,$2,$3)}'`

    #disk remaining space shoule > 500M
    if [ $(to_mb $size) -lt 500 ];then
      dbg_echo "parted_disk_remaining_space: $cur_disk have not enough disk remaining space."
      return $ERROR_PARMETER
    fi

    #formatting the disk
    /bin/parted $cur_disk mkpart primary $start $end >> /dev/null 2&>1
    if [ $? -ne 0 ]; then
      echo "parted_disk_remaining_space: parted $cur_disk error."
      return $ERROR_PARMETER
    fi
    sync

    partname=""

    while [ -z "$partname" ]
    do
      sleep 1
      eval `/bin/parted $cur_disk print free | awk '/primary/ {printf("partname=%s;",$1)}'`
    done
    partname=$cur_disk$partname
    #echo "_PART_NAME: $partname"

    if [ "$fs_type"x != "no_fs"x ];then
      dbg_echo -e "Formatting the remaining partition of $partname \n$fs_type $size"
      /bin/mke2fs -F -t $fs_type $partname -L OTO_DATA >> /dev/null 2>&1
    fi

    if [[ $3 ]];then
      eval $3=$partname
    else
      eval _PART_NAME=$partname
    fi
    eval $4=$fs_type
    sync
  }
  #----------------------------------
  # by: David Chan (chanuei@sina.com)
  # date: 2016-08-31
  #
  # Func: get_hd_fstype
  # Param:
  #   $1, UUID of the partition to detect FS Type
  #   $2, fsType found.
  get_hd_fstype()
  {
    if [ "$#" -ne 2 ]; then
      dbg_echo "GET_HD_FSTYPE: The func should be called with 2 parameters, but $# parameters found"
      return $ERROR_PARMETER
    fi
    
    eval $2="$(for c in `blkid | grep -m 1 -i $1`; do echo $c | grep -i "TYPE" | cut -b6-; done)"
  }
  
  #----------------------------------
  # by: David Chan (chanuei@sina.com)
  # date: 2016-08-31
  #
  # Func: mount_part_via_uuid
  # Param:
  #   $1, uuid of the part to be loaded.
  #   $2, mountpoint, the part to be mounted to.
  #   $3, options, "ro" "rw" etc.
  mount_part_via_uuid()
  {
    if [ "$#" -ne 3 ] && [ "$#" -ne 2 ]; then
      dbg_echo "mount_part_via_uuid: The func should be called with 2 parameters, but $# parameters found"
      return $ERROR_PARMETER
    fi
    
    if [ ! -d "$2" ]; then
      mkdir -p $2
    fi
    local fsType
    get_hd_fstype $1 fsType
    if [ $?=$PARAM_FOUND ] && [ "$#" -eq 3 ]; then
      local varMountOption="-o $3"
    fi
    dbg_echo "fsType for $1 is $fsType"
    if [ "$fsType" = "ntfs" ] || [ "$fsType" = "NTFS" ]; then
      hdPart="$(for c in `blkid | grep -m 1 -i $1`; do	echo $c | grep -i "/dev" | cut -d":" -f1; done)"
      dbg_echo "mount.ntfs-3g $hdPart $2"
      mount.ntfs-3g $hdPart $2
    else
      dbg_echo "mount -t $fsType $varMountOption UUID=$1 $2"
      mount -t $fsType $varMountOption UUID=$1 $2
    fi
  }
  
  #----------------------------------
  # by: David Chan (chanuei@sina.com)
  # date: 2016-08-31
  #
  # Func: mount_os_img
  # Param:
  #   $1, ImageClass of the os image to be loaded. Could be:
  #       RAMDISK, SYSTEM, DATA, INSTALL, RECOVERY, UPDATE.
  #   $2, ImageName of the os image to be loaded, with suffix ".img" or ".sfs".
  #       Such as "system.sfs" or "data.img".
  #   $3, options
  mount_os_img()
  {
    if [ "$#" -ne 3 ] && [ "$#" -ne 2 ]; then
      dbg_echo "mount_os_img: The func should be called with 2 parameters, but $# parameters found"
      return $ERROR_PARMETER
    fi
    
    local osImageOwnerDir="$(echo "/mnt/$1" | tr '[:upper:]' '[:lower:]')"
    if [ ! -d "$osImageOwnerDir" ]; then
      mkdir -p $osImageOwnerDir
    else
      mountpoint -q $osImageOwnerDir
      if [ $? -eq 0 ]; then
        umount $osImageOwnerDir
      fi
    fi
    
    local varUuidClass="$1_HD_UUID"
    get_param_from_bootargs $varUuidClass
    
    local varUuid
    eval varUuid='$'$varUuidClass
    mount_part_via_uuid $varUuid $osImageOwnerDir
    
    local varImg=$osImageOwnerDir/$2
    
    if [ -e "$varImg" ]; then
      case $1 in
      RAMDISK)
        pushd $ANDROID_DIR
        dbg_echo "zcat $varImg | cpio -id"
        zcat $varImg | cpio -id >>/dev/null 2>&1
        popd
        ;;
      SYSTEM | DATA)
        if [ "$(echo $2 | rev | cut -d/ -f1 | cut -d. -f1 | rev)" = "sfs" ]; then
          local sfsMountPoint="$(echo "/mnt/$1.sfs" | tr '[:upper:]' '[:lower:]')"
          if [ ! -d "$sfsMountPoint" ]; then
            mkdir -p "$sfsMountPoint"
          else
            mountpoint -q $sfsMountPoint
            if [ $? -eq 0 ]; then
              umount  $sfsMountPoint
            fi
          fi
          dbg_echo "mount -o loop $varImg $sfsMountPoint"
          mount -o loop $varImg $sfsMountPoint
          varImg=$sfsMountPoint/"$(echo $2 | rev | cut -d/ -f1 | cut -d. -f2 | rev)".img
        elif [ "$(echo $2 | rev | cut -d/ -f1 | cut -d. -f1 | rev)" = "img" ]; then
          :
        else
          dbg_echo "mount_os_img: $2 is not suffixed with \".img\" or \".sfs\""
          return 1
        fi
        pushd $ANDROID_DIR
        local imgMountPoint="$(echo "$1" | tr '[:upper:]' '[:lower:]')"
        mount -o loop -t ext4 $varImg $imgMountPoint
        popd
        ;;
      *)
        ;;
      esac

    else
      dbg_echo /$2 on disk UUID=$varUuid not found
    fi    
  }
  
  #----------------------------------
  # by: David Chan (chanuei@sina.com)
  # date: 2016-08-26
  #
  # Func: prepare_mountpoint
  # Param:
  #   $1, mountpoint to be prepared
  prepare_mountpoint()
  {
    if [ ! -d "$1" ]; then
      mkdir -p $1
    else
      mountpoint -q $1
      if [ "$?" -eq "0" ]; then
        umount $1
      fi
    fi  
  }
  
  #----------------------------------
  # by: David Chan (chanuei@sina.com)
  # date: 2016-08-27
  #
  # Func: mount_live_media
  mount_live_media()
  {
    local i=0
    while [ $i -lt 20 ]; do
      sleep 1s
      blkid | grep "OTO_INSTDSK" >>/dev/null
      if [ $? -eq 0 ]; then
        break
      fi
      let ++i
    done

    if [ $i -eq 20 ]; then
      dbg_echo "Install meida should have label \"OTO_INSTDSK\", please make sure it's right"
      return 1
    fi

    prepare_mountpoint $1
    mount -t vfat LABEL="OTO_INSTDSK" $1
    return 0
  }
  # End: Function definition
  # ------------------------------------------------------------------------------

  #----------------------------------
  # by: David Chan (chanuei@sina.com)
  # date: 2017-02-15
  #
  # Func: mount_eval_media
  mount_eval_media()
  {
    local i=0
    while [ $i -lt 20 ]; do
      sleep 1s
      blkid | grep "OTO_EVALDSK"
      if [ $? -eq 0 ]; then
        break
      fi
      let ++i
    done

    if [ $i -eq 20 ]; then
      dbg_echo "Evaluation meida should have label \"OTO_EVALDSK\", please make sure it's right"
      return 1
    fi

    prepare_mountpoint $1
    mount -t vfat LABEL="OTO_EVALDSK" $1
    return 0
  }
# End: Function definition
# ------------------------------------------------------------------------------

# Begin: base init
# ==============================================================================
  dbg_echo "Stage init start..."
  
  wait_for_blkdev

  dbg_echo "base init: boot mode detecting ..."
  get_param_from_bootargs BOOT_MODE
  dbg_echo "              BOOT_MODE is $BOOT_MODE"
  
  case $BOOT_MODE in
  install)
    dbg_echo "base init: will boot OpenThos in install mode"
    mount_live_media $LIVEMEDIA_DIR
    zcat $LIVEMEDIA_DIR/OpenThos/install.img | cpio -id  >/dev/null 2>&1
    insmod bin/atkbd.ko

    ln -s /bin/mke2fs /bin/make_ext4fs
    ln -s /bin/mkfs.fat /bin/mkdosfs
    ln -s /bin/ntfs-3g /bin/mount.ntfs-3g
    
    
    get_param_from_bootargs INST_MODE
    insmod /bin/efivarfs.ko
    mount -t efivarfs none /sys/firmware/efi/efivars
    if [ "$INST_MODE" = "hdimg" ]; then
      source /scripts/2-boto_install
      hdimg_install
    else
      source /scripts/1-install
      hd_install
    fi
    ;;
    
  liveboot)
    dbg_echo "base init: will boot OpenThos in live mode."
    mount_live_media $LIVEMEDIA_DIR
    
    pushd $ANDROID_DIR
    zcat $LIVEMEDIA_DIR/OpenThos/ramdisk.img | cpio -id  >/dev/null 2>&1
    if [ -e "$LIVEMEDIA_DIR/OpenThos/system.img" ]; then
      prepare_mountpoint $ANDROID_DIR/system
      mount -t ext4 -o loop,ro $LIVEMEDIA_DIR/OpenThos/system.img system
    elif [ -e  "$LIVEMEDIA_DIR/OpenThos/system.sfs" ]; then
      prepare_mountpoint /mnt/system.sfs
      mount -o loop $LIVEMEDIA_DIR/OpenThos/system.sfs /mnt/system.sfs
      prepare_mountpoint $ANDROID_DIR/system
      mount -t ext4 -o loop /mnt/system.sfs/system.img system
    else
      :
    fi

    mount -t tmpfs tmpfs data

    popd

    prepare_mountpoint $ANDROID_DIR/data

    get_param_from_bootargs DATA_HD_UUID

    if [ -n "$DATA_HD_UUID" ];then
      mount_part_via_uuid $DATA_HD_UUID $ANDROID_DIR/data
      dbg_echo "Found the data partition: $DATA_HD_UUID"
      else
	DATA_PART=""
	#parted and format the usb remaining space
	parted_disk_remaining_space "" "" DATA_PART DATA_FS
	if [ -b "$DATA_PART" ]; then
          dbg_echo "Evaluation mode success: $DATA_PART"
	  DATA_UUID=`blkid "$DATA_PART"|awk -F "UUID" '{print $2;}'|awk -F "\"" '{print $2;}'`
          data_uuid="DATA_HD_UUID=$DATA_UUID"
          sed -i "1,2 s/\"$/ $data_uuid\"/" $LIVEMEDIA_DIR/OpenThos/boto_linux.conf
          sync
	  mount -t $DATA_FS $DATA_PART $ANDROID_DIR/data
	else
	  dbg_echo "Evaluation mode failed."
	  mount -t tmpfs tmpfs $ANDROID_DIR/data
	fi

    fi
    ;;
    
  evalboot)
    dbg_echo "base init: will boot OpenThos in evaluation mode."
    mount_eval_media $LIVEMEDIA_DIR

    pushd $ANDROID_DIR
    zcat $LIVEMEDIA_DIR/OpenThos/ramdisk.img | cpio -id  >/dev/null 2>&1
    if [ -e "$LIVEMEDIA_DIR/OpenThos/system.img" ]; then
      prepare_mountpoint $ANDROID_DIR/system
      mount -o loop,ro $LIVEMEDIA_DIR/OpenThos/system.img system
    elif [ -e  "$LIVEMEDIA_DIR/OpenThos/system.sfs" ]; then
      prepare_mountpoint /mnt/system.sfs
      mount -o loop $LIVEMEDIA_DIR/OpenThos/system.sfs /mnt/system.sfs
      prepare_mountpoint $ANDROID_DIR/system
      mount -o loop /mnt/system.sfs/system.img system
    else
      :
    fi

    mount -o loop $LIVEMEDIA_DIR/OpenThos/data.img data

    popd

    ;;

  hdimgboot)
    source /scripts/oto_update.sh
    openthos_update
    dbg_echo "base init: will boot OpenThos from local disk images."

    get_param_from_bootargs RAMDISK_IMG
    mount_os_img RAMDISK $RAMDISK_IMG

    get_param_from_bootargs SYSTEM_IMG
    mount_os_img SYSTEM $SYSTEM_IMG

    get_param_from_bootargs DATA_IMG
    ntfsfix `blkid|awk -F ":" '/'$DATA_IMAGE'/{print $1}'` > /dev/null
    mount_os_img DATA $DATA_IMG
    ;;
    
  hdboot)
    source /scripts/oto_update.sh
    openthos_update
    pushd $ANDROID_DIR

    dbg_echo "base init: will boot OpenThos from local disk partitions."

    get_param_from_bootargs RAMDISK_IMG
    mount_os_img RAMDISK $RAMDISK_IMG
    get_param_from_bootargs SYSTEM_HD_UUID
    if [ -n "$SYSTEM_HD_UUID" ]; then
      mount_part_via_uuid $SYSTEM_HD_UUID system ro
    else
      dbg_echo "base init: no SYSTEM_HD_UUID found, will try the default contents"
    fi
    
    get_param_from_bootargs DATA_HD_UUID
    if [ -n "$DATA_HD_UUID" ]; then
      mount_part_via_uuid $DATA_HD_UUID data
    else
      dbg_echo "base init: no DATA_HD_UUID found, will try the default contents"
    fi
        
    popd
    ;;
    
  *)
    
    ;;
  esac
  
  
  dbg_echo "Stage init finished."
# End: init
# ------------------------------------------------------------------------------

# Begin: boot android
# ==============================================================================
  dbg_echo "Stage boot android start..."

  pushd $ANDROID_DIR

  ln -s /android/system /
  ln -s /system/lib/firmware /system/lib/modules /lib

  mv /bin /lib .
  sed -i 's|\( PATH.*\)|\1:/bin|' init.environ.rc
  rm /sbin/modprobe
  busybox mv /sbin/* sbin
  rmdir /sbin
  ln -s android/bin android/lib android/sbin /
  hash -r

# ensure keyboard driver is loaded
  busybox modprobe atkbd

  get_param_from_bootargs DEBUG

  if [ 0$DEBUG -gt 0 ]; then
    echo -e "\nType 'exit' to continue booting...\n"
    debug_shell debug-found
  fi

  get_param_from_bootargs RECOVERY
  if [ "$RECOVERY" = "1" -o -e /android/data/rec_reset ];then
    recovery_hint
    if [ $? -eq 0 ];then
       get_param_from_bootargs DATA_HD_UUID
       DATA_PART=`blkid | grep $DATA_HD_UUID | awk -F ":" '{print $1;}'`
       DATA_FS=`blkid | grep $DATA_HD_UUID | awk -F "TYPE=" '{print $2;}' | cut -d \" -f 2`
       umount -f $DATA_PART
       mke2fs -t $DATA_FS -L "oto_data" -U $DATA_HD_UUID -F $DATA_PART > /dev/null
       mount $DATA_PART data
    fi
  fi


# load scripts

  dbg_echo Load Scripts.....
  for s in `ls /scripts/*`; do
    test -e "$s" && source $s
  done

# Other normal steps
  load_modules
#mount_data
  mount_sdcard
  setup_tslib
  setup_dpi
#post_detect

  if [ 0$DEBUG -gt 1 ]; then
    echo -e "\nUse Alt-F1/F2/F3 to switch between virtual consoles"
    echo -e "Type 'exit' to enter Android...\n"

    debug_shell debug-late
  fi
  [ -n "$DEBUG" ] && SWITCH=${SWITCH:-chroot}

# We must disable mdev before switching to Android
# since it conflicts with Android's init
  echo > /proc/sys/kernel/hotplug

  exec ${SWITCH:-switch_root} /android /init

  
  dbg_echo "Stage boot android finished."
# End: boot android
# ------------------------------------------------------------------------------

while :; do
  debug_shell fatal-err
done

